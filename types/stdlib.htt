# Useful reference:
# https://tiagodev.wordpress.com/2013/04/16/eigenclasses-for-lunch-the-ruby-object-model/

#!magic basicobject
class BasicObject
    #: () -> void
    def initialize; end

    #: (Class) -> Boolean
    def is_a?(_); end
end

class Class < Module
    #: () -> Class
    def superclass; end

    #: () -> void
    def initialize; end

    #: () -> Object
    # Special case of `new` being defined as a method rather than magically - this only affects the
    # rather rare usage `Class.new.new`, not anything else e.g. `Object.new`
    def new; end

    #: (Symbol) -> void
    #!const required_internal
    def attr_reader(name); end

    # TODO: Method visibility setters are only supported in their argument-taking form
    
    #: (Symbol) -> void
    #!const required_internal
    def private(name); end

    #: (Symbol) -> void
    #!const required_internal
    def protected(name); end
end

class Object < BasicObject
    #: () -> String
    def inspect; end

    #: (Object) -> Boolean
    def ==(other); end
end

class Module
    #: () -> Array[Module]
    def nesting; end
end

class Numeric
    #: (Numeric) -> Numeric
    #!const internal
    def +(other); end

    #: (Numeric) -> Boolean
    def >(other); end

    #: (Numeric) -> Boolean
    def >=(other); end

    #: (Numeric) -> Boolean
    def <(other); end

    #: (Numeric) -> Boolean
    def <=(other); end
end

class Integer < Numeric
    #: (Integer) -> Integer
    #: (Float) -> Float
    #!const internal
    def +(other); end

    #: () { (Integer) -> void } -> Integer
    def times; end

    #: () -> Integer
    def abs; end
end

class Float < Numeric
    #: (Integer) -> Float
    #: (Float) -> Float
    #!const internal
    def +(other); end

    #: () -> Float
    def abs; end
end

class String
    #: (String) -> String
    def +(other); end

    #: () -> Integer
    def length; end
end

class Symbol; end

#!param T
class Array
    #: (T) -> Array[T]
    def <<(item); end

    # TODO: should be nilable
    #: (Integer) -> T
    def [](index); end

    #: () -> Integer
    def length; end

    #: () { (T) -> void } -> Array[T]
    def each; end
end

# Doesn't actually exist, but we need some kind of boolean type
class Boolean; end
class TrueClass < Boolean; end
class FalseClass < Boolean; end

class NilClass; end

class Kernel
    #: (?Float) -> Float
    #: (Integer) -> Integer
    def self.rand(max=nil); end

    #!const internal
    #: (?untyped) -> void
    def self.puts(message=nil); end

    #!const internal
    #: (?untyped) -> void
    def self.print(message=nil); end
end
